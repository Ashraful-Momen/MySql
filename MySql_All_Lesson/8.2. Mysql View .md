
---

## **MySQL View**

A **View** in MySQL is a **virtual table** based on the result of a **SELECT query**. It behaves like a table but **does not store data physically**. Every time you query a view, MySQL dynamically runs the query behind it.

---

### **Why Use Views?**

* Simplify complex SQL queries.
* Abstract sensitive columns (security).
* Present data in a particular format.
* Create reusable query structures.
* Simplify report generation.

---

### **Scenario Example**

Suppose you have a database tracking **Employees and Departments**.

**Tables:**

**Employee Table**

```
+----+----------+-----------+--------+
| ID | Name     | Dept_ID   | Salary |
+----+----------+-----------+--------+
| 1  | Alice    | 1         | 60000  |
| 2  | Bob      | 2         | 55000  |
| 3  | Charlie  | 1         | 70000  |
+----+----------+-----------+--------+
```

**Department Table**

```
+---------+----------------+
| Dept_ID | Department_Name |
+---------+----------------+
| 1       | IT             |
| 2       | HR             |
+---------+----------------+
```

You want a simple **Employee Info View** that shows Employee Name, Department Name, and Salary.

---

### **Creating a View**

```sql
CREATE VIEW EmployeeInfo AS
SELECT 
    e.Name AS EmployeeName,
    d.Department_Name AS Department,
    e.Salary
FROM 
    Employee e
JOIN 
    Department d ON e.Dept_ID = d.Dept_ID;
```

---

### **ASCII Representation**

Underlying Tables:

```
EMPLOYEE
+----+----------+-----------+--------+
| ID | Name     | Dept_ID   | Salary |
+----+----------+-----------+--------+

DEPARTMENT
+---------+----------------+
| Dept_ID | Department_Name |
+---------+----------------+
```

Virtual View Table:

```
EMPLOYEEINFO VIEW
+--------------+-------------+--------+
| EmployeeName | Department  | Salary |
+--------------+-------------+--------+
| Alice        | IT          | 60000  |
| Bob          | HR          | 55000  |
| Charlie      | IT          | 70000  |
+--------------+-------------+--------+
```

---

### **Querying a View**

```sql
SELECT * FROM EmployeeInfo;
```

* Output will be just like a regular table.

---

### **Updating Data Through Views**

* If the view is **updatable**, you can modify data:

```sql
UPDATE EmployeeInfo SET Salary = 75000 WHERE EmployeeName = 'Alice';
```

* This will update the underlying **Employee** table.

---

### **When Views Are NOT Updatable**

A view becomes **non-updatable** if:

| **Condition**                   | **Example**                         |
| ------------------------------- | ----------------------------------- |
| Uses **GROUP BY**               | Aggregated summaries                |
| Uses **DISTINCT**               | Removes duplicates                  |
| Has **UNION**                   | Combines rows from multiple queries |
| Uses **Subqueries in SELECT**   | Nested SELECT in column list        |
| Has **JOIN of multiple tables** | But no unique primary key mapping   |

---

### **Force Updatable View (WITH CHECK OPTION)**

```sql
CREATE VIEW HighSalaryEmployees AS
SELECT * FROM Employee WHERE Salary > 60000
WITH CHECK OPTION;
```

* Prevents inserting or updating rows that donâ€™t meet `Salary > 60000` condition.

---

### **Modifying & Dropping a View**

| **Operation** | **SQL Command**            |
| ------------- | -------------------------- |
| Modify a View | CREATE OR REPLACE VIEW ... |
| Drop a View   | DROP VIEW EmployeeInfo;    |

---

### **Advantages of Using Views**

| **Advantage**              | **Description**                                   |
| -------------------------- | ------------------------------------------------- |
| Simplifies Complex Queries | Encapsulate joins and filters in a view           |
| Provides Security          | Hide sensitive columns (like salaries)            |
| Reusability                | Write query logic once, use everywhere            |
| Logical Abstraction        | Change underlying tables without changing queries |

---

### **Disadvantages of Views**

| **Disadvantage**                 | **Explanation**                                  |
| -------------------------------- | ------------------------------------------------ |
| No Physical Storage              | Can be slower for large datasets                 |
| Non-Updatable in Some Cases      | Complex views can't be updated directly          |
| Nested Views Degrade Performance | Views based on other views can slow down queries |

---

### **Materialized View?**

* **MySQL does NOT have materialized views natively.**
* Materialized View = View where **data is stored physically**.
* You can simulate it using **Tables + Triggers + Events**.

---

### **Check View Definition**

```sql
SHOW CREATE VIEW EmployeeInfo\G
```

---

## **Summary**

* View = **Virtual Table** (dynamic query result).
* Simplifies complex queries, provides abstraction & security.
* Can be updatable or read-only based on complexity.
* Managed with **CREATE, REPLACE, DROP** commands.
* MySQL views are **non-materialized** (always dynamic).

---
