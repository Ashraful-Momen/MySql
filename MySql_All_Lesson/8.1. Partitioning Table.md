
---

## **MySQL Partitioning**

Partitioning is a database design technique that **divides large tables into smaller, manageable pieces** (called **partitions**) to improve **performance, scalability, and maintenance**.

---

### **Why Use Partitioning?**

* Speeds up queries on large datasets.
* Makes data archiving and purging easier.
* Improves maintenance by isolating sections of data.
* Helps distribute data across multiple storage devices.

---

### **Types of Partitioning in MySQL**

1. **RANGE Partitioning**

   * Rows are assigned to partitions based on column **range values**.
   * Example: Partitioning by year.

2. **LIST Partitioning**

   * Rows are assigned to partitions based on a **list of discrete values**.
   * Example: Partitioning by country code.

3. **HASH Partitioning**

   * Rows are assigned to partitions based on the **result of a hash function**.
   * Example: Evenly distributing data.

4. **KEY Partitioning**

   * Similar to HASH but MySQL chooses the hashing algorithm.
   * Example: Used when no good hash column is obvious.

---

### **Simple Example Scenario**

A table of **sales records** for multiple years. We want to partition it **by year** to make querying per year faster.

---

### **Before Partitioning (Big Table)**

```
+----+------------+-------+
| ID | Sale_Date  | Amount|
+----+------------+-------+
| 1  | 2021-06-01 | 500   |
| 2  | 2022-03-15 | 750   |
| 3  | 2023-09-10 | 1200  |
| 4  | 2024-01-05 | 900   |
+----+------------+-------+
```

* All rows are in one big table = slower queries on specific years.

---

### **After RANGE Partitioning (By Year)**

```
PARTITION p2021 -> Rows where YEAR(Sale_Date) = 2021
PARTITION p2022 -> Rows where YEAR(Sale_Date) = 2022
PARTITION p2023 -> Rows where YEAR(Sale_Date) = 2023
PARTITION p2024 -> Rows where YEAR(Sale_Date) = 2024
```

---

### **MySQL Partitioning Example**

```sql
-- Create Partitioned Table
CREATE TABLE Sales (
    ID INT NOT NULL,
    Sale_Date DATE NOT NULL,
    Amount DECIMAL(10,2),
    PRIMARY KEY (ID, Sale_Date)
)
PARTITION BY RANGE (YEAR(Sale_Date)) (
    PARTITION p2021 VALUES LESS THAN (2022),
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025)
);

-- Insert Data
INSERT INTO Sales VALUES (1, '2021-06-01', 500);
INSERT INTO Sales VALUES (2, '2022-03-15', 750);
INSERT INTO Sales VALUES (3, '2023-09-10', 1200);
INSERT INTO Sales VALUES (4, '2024-01-05', 900);
```

---

### **ASCII Representation**

Before Partitioning:

```
SALES TABLE
+----+------------+-------+
| ID | Sale_Date  | Amount|
+----+------------+-------+
| 1  | 2021-06-01 | 500   |
| 2  | 2022-03-15 | 750   |
| 3  | 2023-09-10 | 1200  |
| 4  | 2024-01-05 | 900   |
+----+------------+-------+
```

After Partitioning:

```
PARTITION p2021
+----+------------+-------+
| 1  | 2021-06-01 | 500   |

PARTITION p2022
+----+------------+-------+
| 2  | 2022-03-15 | 750   |

PARTITION p2023
+----+------------+-------+
| 3  | 2023-09-10 | 1200  |

PARTITION p2024
+----+------------+-------+
| 4  | 2024-01-05 | 900   |
```

---

### **Other Partitioning Examples**

#### **LIST Partitioning (By Country Code)**

```sql
CREATE TABLE Customers (
    ID INT,
    Country_Code CHAR(2)
)
PARTITION BY LIST COLUMNS (Country_Code) (
    PARTITION asia VALUES IN ('IN', 'BD', 'PK'),
    PARTITION europe VALUES IN ('FR', 'DE', 'UK'),
    PARTITION usa VALUES IN ('US')
);
```

#### **HASH Partitioning (Distribute Evenly)**

```sql
CREATE TABLE Logs (
    ID INT,
    Log_Message TEXT
)
PARTITION BY HASH(ID) PARTITIONS 4;
```

* Data will be spread across 4 partitions based on ID hash.

---

### **Important Notes**

* Partitioning works only on **InnoDB** and **MyISAM**.
* The **partitioning key** must be part of every **Primary Key/Unique Key**.
* You can only partition **base tables**, not views.
* Improper partitioning can **degrade performance**.

---

### **When to Use Partitioning**

| **Use Case**                         | **Type** |
| ------------------------------------ | -------- |
| Archiving old data yearly            | RANGE    |
| Partitioning by categories (country) | LIST     |
| Distributing rows evenly             | HASH     |
| No obvious hash column               | KEY      |

---

### **Check Partitions**

```sql
SELECT TABLE_NAME, PARTITION_NAME, SUBPARTITION_NAME, PARTITION_ORDINAL_POSITION, TABLE_ROWS
FROM INFORMATION_SCHEMA.PARTITIONS
WHERE TABLE_NAME = 'Sales';
```

---

### **Partition Maintenance**

| **Operation**                   | **Command**                                |
| ------------------------------- | ------------------------------------------ |
| Add new partition               | ALTER TABLE Sales ADD PARTITION (...)      |
| Drop a partition                | ALTER TABLE Sales DROP PARTITION p2021;    |
| Rebuild partition               | ALTER TABLE Sales REBUILD PARTITION p2022; |
| Remove Partitioning (Merge all) | ALTER TABLE Sales REMOVE PARTITIONING;     |

---

## **Summary**

* Partitioning = Splitting large tables into **smaller logical pieces**.
* Helps in **query performance, scalability, and easier data management**.
* Choose **RANGE, LIST, HASH, or KEY** based on use case.
* Requires careful design to avoid performance penalties.

---
