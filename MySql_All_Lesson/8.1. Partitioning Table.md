
---

## **MySQL Partitioning**

Partitioning is a database design technique that **divides large tables into smaller, manageable pieces** (called **partitions**) to improve **performance, scalability, and maintenance**.

---

### **Why Use Partitioning?**

* Speeds up queries on large datasets.
* Makes data archiving and purging easier.
* Improves maintenance by isolating sections of data.
* Helps distribute data across multiple storage devices.

---

### **Types of Partitioning in MySQL**

1. **RANGE Partitioning**

   * Rows are assigned to partitions based on column **range values**.
   * Example: Partitioning by year.

2. **LIST Partitioning**

   * Rows are assigned to partitions based on a **list of discrete values**.
   * Example: Partitioning by country code.

3. **HASH Partitioning**

   * Rows are assigned to partitions based on the **result of a hash function**.
   * Example: Evenly distributing data.

4. **KEY Partitioning**

   * Similar to HASH but MySQL chooses the hashing algorithm.
   * Example: Used when no good hash column is obvious.

---

--------------------------------------------------
1. RANGE Partitioning (by year)
--------------------------------------------------
```sql
-- 1.  Table partitioned by YEAR(sold_date)
CREATE TABLE sales_range (
    id          INT AUTO_INCREMENT PRIMARY KEY,
    product     VARCHAR(40),
    sold_date   DATE,
    amount      DECIMAL(10,2)
)
PARTITION BY RANGE (YEAR(sold_date)) (
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION pmax  VALUES LESS THAN MAXVALUE
);

-- 2.  Insert a 2023 row
INSERT INTO sales_range (product, sold_date, amount)
VALUES ('Mouse', '2023-08-17', 49.90);

-- 3.  Check partition pruning
EXPLAIN PARTITIONS
SELECT * FROM sales_range WHERE sold_date = '2023-08-17';
-- Result shows only partition p2023 is scanned
```

--------------------------------------------------
2. LIST Partitioning (by region code)
--------------------------------------------------
```sql
-- 1.  Table partitioned by region code
CREATE TABLE sales_list (
    id          INT AUTO_INCREMENT PRIMARY KEY,
    product     VARCHAR(40),
    region_code CHAR(2),          -- NA, EU, AP, etc.
    amount      DECIMAL(10,2)
)
PARTITION BY LIST COLUMNS (region_code) (
    PARTITION p_na VALUES IN ('NA','US','CA'),
    PARTITION p_eu VALUES IN ('EU','UK','DE','FR'),
    PARTITION p_ap VALUES IN ('AP','CN','JP','IN'),
    PARTITION p_row VALUES IN ('OC','AF','SA')
);

-- 2.  Insert an EU row
INSERT INTO sales_list (product, region_code, amount)
VALUES ('Keyboard', 'DE', 129.00);

-- 3.  Verify partition used
EXPLAIN PARTITIONS
SELECT * FROM sales_list WHERE region_code = 'DE';
-- Only partition p_eu is touched
```

--------------------------------------------------
3. HASH Partitioning (even split on `store_id`)
--------------------------------------------------
```sql
-- 1.  Table split into 4 hash partitions
CREATE TABLE sales_hash (
    id       INT AUTO_INCREMENT PRIMARY KEY,
    product  VARCHAR(40),
    store_id INT,
    amount   DECIMAL(10,2)
)
PARTITION BY HASH(store_id)
PARTITIONS 4;          -- MySQL will create p0, p1, p2, p3

-- 2.  Insert two rows
INSERT INTO sales_hash (product, store_id, amount) VALUES
  ('Monitor', 103, 299.00),
  ('Headset', 205, 89.00);

-- 3.  Which partitions?
SELECT PARTITION_NAME, TABLE_ROWS
FROM INFORMATION_SCHEMA.PARTITIONS
WHERE TABLE_NAME = 'sales_hash';
-- You’ll see rows distributed roughly evenly
```

--------------------------------------------------
4. KEY Partitioning (MySQL picks the hash)
--------------------------------------------------
```sql
-- 1.  Table with KEY partitioning (no column needed)
CREATE TABLE sales_key (
    id         INT AUTO_INCREMENT PRIMARY KEY,
    product    VARCHAR(40),
    order_uuid CHAR(36),          -- UUID string
    amount     DECIMAL(10,2)
)
PARTITION BY KEY()
PARTITIONS 5;          -- MySQL hashes the primary key

-- 2.  Insert a row
INSERT INTO sales_key (product, order_uuid, amount)
VALUES ('Webcam', UUID(), 79.90);

-- 3.  Confirm partition pruning
EXPLAIN PARTITIONS
SELECT * FROM sales_key WHERE id = 5;
-- Only one partition (e.g. p3) appears in the plan
```

Run each block in any MySQL 8.x instance and you’ll see the optimizer prune to the single correct partition every time.


### **Simple Example Scenario**

A table of **sales records** for multiple years. We want to partition it **by year** to make querying per year faster.

---

### **Before Partitioning (Big Table)**

```
+----+------------+-------+
| ID | Sale_Date  | Amount|
+----+------------+-------+
| 1  | 2021-06-01 | 500   |
| 2  | 2022-03-15 | 750   |
| 3  | 2023-09-10 | 1200  |
| 4  | 2024-01-05 | 900   |
+----+------------+-------+
```

* All rows are in one big table = slower queries on specific years.

---

### **After RANGE Partitioning (By Year)**

```
PARTITION p2021 -> Rows where YEAR(Sale_Date) = 2021
PARTITION p2022 -> Rows where YEAR(Sale_Date) = 2022
PARTITION p2023 -> Rows where YEAR(Sale_Date) = 2023
PARTITION p2024 -> Rows where YEAR(Sale_Date) = 2024
```

---

### **MySQL Partitioning Example**

```sql
-- Create Partitioned Table
CREATE TABLE Sales (
    ID INT NOT NULL,
    Sale_Date DATE NOT NULL,
    Amount DECIMAL(10,2),
    PRIMARY KEY (ID, Sale_Date)
)
PARTITION BY RANGE (YEAR(Sale_Date)) (
    PARTITION p2021 VALUES LESS THAN (2022),
    PARTITION p2022 VALUES LESS THAN (2023),
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025)
);

-- Insert Data
INSERT INTO Sales VALUES (1, '2021-06-01', 500);
INSERT INTO Sales VALUES (2, '2022-03-15', 750);
INSERT INTO Sales VALUES (3, '2023-09-10', 1200);
INSERT INTO Sales VALUES (4, '2024-01-05', 900);
```

---

### **ASCII Representation**

Before Partitioning:

```
SALES TABLE
+----+------------+-------+
| ID | Sale_Date  | Amount|
+----+------------+-------+
| 1  | 2021-06-01 | 500   |
| 2  | 2022-03-15 | 750   |
| 3  | 2023-09-10 | 1200  |
| 4  | 2024-01-05 | 900   |
+----+------------+-------+
```

After Partitioning:

```
PARTITION p2021
+----+------------+-------+
| 1  | 2021-06-01 | 500   |

PARTITION p2022
+----+------------+-------+
| 2  | 2022-03-15 | 750   |

PARTITION p2023
+----+------------+-------+
| 3  | 2023-09-10 | 1200  |

PARTITION p2024
+----+------------+-------+
| 4  | 2024-01-05 | 900   |
```

---

### **Other Partitioning Examples**

#### **LIST Partitioning (By Country Code)**

```sql
CREATE TABLE Customers (
    ID INT,
    Country_Code CHAR(2)
)
PARTITION BY LIST COLUMNS (Country_Code) (
    PARTITION asia VALUES IN ('IN', 'BD', 'PK'),
    PARTITION europe VALUES IN ('FR', 'DE', 'UK'),
    PARTITION usa VALUES IN ('US')
);
```

#### **HASH Partitioning (Distribute Evenly)**

```sql
CREATE TABLE Logs (
    ID INT,
    Log_Message TEXT
)
PARTITION BY HASH(ID) PARTITIONS 4;
```

* Data will be spread across 4 partitions based on ID hash.

---

### **Important Notes**

* Partitioning works only on **InnoDB** and **MyISAM**.
* The **partitioning key** must be part of every **Primary Key/Unique Key**.
* You can only partition **base tables**, not views.
* Improper partitioning can **degrade performance**.

---

### **When to Use Partitioning**

| **Use Case**                         | **Type** |
| ------------------------------------ | -------- |
| Archiving old data yearly            | RANGE    |
| Partitioning by categories (country) | LIST     |
| Distributing rows evenly             | HASH     |
| No obvious hash column               | KEY      |

---

### **Check Partitions**

```sql
SELECT TABLE_NAME, PARTITION_NAME, SUBPARTITION_NAME, PARTITION_ORDINAL_POSITION, TABLE_ROWS
FROM INFORMATION_SCHEMA.PARTITIONS
WHERE TABLE_NAME = 'Sales';
```

---

### **Partition Maintenance**

| **Operation**                   | **Command**                                |
| ------------------------------- | ------------------------------------------ |
| Add new partition               | ALTER TABLE Sales ADD PARTITION (...)      |
| Drop a partition                | ALTER TABLE Sales DROP PARTITION p2021;    |
| Rebuild partition               | ALTER TABLE Sales REBUILD PARTITION p2022; |
| Remove Partitioning (Merge all) | ALTER TABLE Sales REMOVE PARTITIONING;     |

---

Below are four **copy/paste-ready** MySQL snippets—one per partitioning type—using a realistic `sales` table.  
Each example includes:
1. Table definition with partition clause  
2. A quick `INSERT` to show which partition receives the row  
3. `EXPLAIN PARTITIONS` query so you can see partition pruning in action



## **Summary**

* Partitioning = Splitting large tables into **smaller logical pieces**.
* Helps in **query performance, scalability, and easier data management**.
* Choose **RANGE, LIST, HASH, or KEY** based on use case.
* Requires careful design to avoid performance penalties.

---
